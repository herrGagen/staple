This document is divided into 3 chapters.  For the three combinatorial optimization problems considered, we define and analyze the problme space and objective, formulate candidate algorithms and then subject those algorithms to theoretical and experimental analysis.

The recurring theme of using experimental approaches permeates all of the chapters.  This enforces a few things in our algorithms. {\it First}, they all must be simple enough to be implemented in code by a technically savvy reader.  Even the most complex algorithm contained herein (a dyanamic programming based PTAS) has easily implemented subfunctions that are described at or near the pseudocode level.  {\it Second}, they must have reasonable running times.  If an algorithm takes more than a second or two to crunch an instance with a dozen input points, we will not be able to run it enough times to get meaningful statistics on its performance.  On modern computers, this translates to algorithms of $O(n^8)$ or higher being considered completely unwieldy.

The advantages of using working under such constraints is that we can use the power of experiments while formulating our ideas. Preliminary results of bad case behaviors of algorithms queued us when to reformulate some algorithms and quickly abandon other unfruitful approaches. Another advantage of an insistence on quick algorithms is that they enable general metaheuristic optimization techniques. These techniques evaluate their scoring algorithms many times and do not bound their performance, but in practice do a very good job of exploring multidimensional input spaces.

The first chapter asks the question: how many 2 element exchanges are required to order a random permutation of objects so that all objects of the same class find themselves in a continuous block. The problem we focus on is similar to Djikstra’s Dutch Flag problem, but his 3 classes of unrestricted sizes with a known final configuration are replaced by our unlimited number of classes with restricted sizes and an unknown final configuration.

Our second chapter answers an algorithmic question in DNA copynumber analysis brought to our attention by a collaborator at Cold Spring Harbor Laboratory. We analyzed the worst case behavior of his simple greedy algorithm and then formulated alternative approaches based on integer programming and the problem’s underlying structural similarity to interval graphs.  These approaches were tested experimentally and compared to the original geedy formulation in order to provide a practical tool for DNA copy number analysis.

The final chapter is another permutation problem dubbed the 1D Waiter Problem.  It is a packing problem where the final position of all objects is known and the challenge is to place them all in such an order that the center of mass as each item is placed is contained in a small interval.  This problem is a generalization of the well esxplored packing problem where only the final position of the center of mass is measured, and raises some new challenges.  
